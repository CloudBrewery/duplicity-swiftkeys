#!/usr/bin/env python
# -*- Mode:Python; indent-tabs-mode:nil; tab-width:4 -*-
#
# duplicity -- Encrypted bandwidth efficient backup
# Version $version released $reldate
#
# Copyright 2002 Ben Escoto <ben@emerose.org>
# Copyright 2007 Kenneth Loafman <kenneth@loafman.com>
#
# This file is part of duplicity.
#
# Duplicity is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# Duplicity is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with duplicity; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
# See http://www.nongnu.org/duplicity for more information.
# Please send mail to me or the mailing list if you find bugs or have
# any suggestions.

from __future__ import generators
import getpass, gzip, os, sys, time, types
import traceback, platform, statvfs, resource

import gettext
gettext.install('duplicity')

import duplicity.backends
import duplicity.errors

from duplicity import collections
from duplicity import commandline
from duplicity import diffdir
from duplicity import dup_temp
from duplicity import dup_time
from duplicity import file_naming
from duplicity import globals
from duplicity import gpg
from duplicity import log
from duplicity import manifest
from duplicity import patchdir
from duplicity import path
from duplicity import robust
from duplicity import tempdir
from duplicity import asyncscheduler
from duplicity import util

# If exit_val is not None, exit with given value at end.
exit_val = None


def get_passphrase(n, action):
    """
    Check to make sure passphrase is indeed needed, then get
    the passphrase from environment, from gpg-agent, or user

    If n=3, a password is requested and verified. If n=2, the current
    password is verified. If n=1, a password is requested without
    verification for the time being.

    @type  n: int
    @param n: action to perform
    @rtype: string
    @return: passphrase
    """

    # First try the environment
    try:
        return os.environ['PASSPHRASE']
    except KeyError:
        pass

    # Next, verify we need to ask the user

    # Assumptions:
    #   - encrypt-key has no passphrase
    #   - sign-key requires passphrase
    #   - gpg-agent supplies all, no user interaction

    # no passphrase if --no-encryption or --use-agent
    if not globals.encryption or globals.use_agent:
        return ""

    # no passphrase if --list-current and --archive-dir
    elif (action == "list-current"
          and globals.archive_dir):
        return ""

    # these commands don't look inside the collection
    elif action in ["collection-status",
                    "remove-older-than",
                    "remove-all-but-n-full",
                    ]:
        return ""

    # for a full backup, we don't need a password if
    # there is no sign_key and there are recipients
    elif (action == "full"
          and globals.gpg_profile.recipients
          and not globals.gpg_profile.sign_key):
        return ""

    # for an inc backup, we don't need a password if
    # there is no sign_key and there are recipients
    # and there is an archive-dir specified
    elif (action == "inc"
          and globals.gpg_profile.recipients
          and not globals.gpg_profile.sign_key
          and globals.archive_dir):
        return ""

    # Finally, ask the user for the passphrase
    else:
        log.Info("PASSPHRASE variable not set, asking user.")
        while 1:
            if n == 2:
                pass1 = globals.gpg_profile.passphrase
            else:
                pass1 = getpass.getpass("GnuPG passphrase: ")

            if n == 1:
                pass2 = pass1
            else:
                pass2 = getpass.getpass("Retype passphrase to confirm: ")

            if not pass1 == pass2:
                print "First and second passphrases do not match!  Please try again."
                n = 3
                continue

            if not pass1 and not globals.gpg_profile.recipients:
                print "Cannot use empty passphrase with symmetric encryption!  Please try again."
                n = 3
                continue

            return pass1


def dummy_backup(tarblock_iter):
    """
    Fake writing to backend, but do go through all the source paths.

    @type tarblock_iter: tarblock_iter
    @param tarblock_iter: iterator for current tar block

    @rtype: int
    @return: constant 0 (zero)
    """
    try:
        # Just spin our wheels
        while tarblock_iter.next():
            pass
    except StopIteration:
        pass
    log.Progress(None, diffdir.stats.SourceFileSize)
    return 0


def write_multivol(backup_type, tarblock_iter, backend):
    """
    Encrypt volumes of tarblock_iter and write to backend

    backup_type should be "inc" or "full" and only matters here when
    picking the filenames.  The path_prefix will determine the names
    of the files written to backend.  Also writes manifest file.
    Returns number of bytes written.

    @type backup_type: string
    @param backup_type: type of backup to perform, either 'inc' or 'full'
    @type tarblock_iter: tarblock_iter
    @param tarblock_iter: iterator for current tar block
    @type backend: callable backend object
    @param backend: I/O backend for selected protocol

    @rtype: int
    @return: bytes written
    """

    def get_indicies(tarblock_iter):
        """Return start_index and end_index of previous volume"""
        start_index = tarblock_iter.recall_index()
        if start_index is None:
            start_index = ()
        end_index = tarblock_iter.get_previous_index()
        if end_index is None:
            end_index = start_index
        return start_index, end_index

    def put(tdp, dest_filename):
        backend.put(tdp, dest_filename)
        putsize = tdp.getsize()
        tdp.delete()
        return putsize

    at_end = 0
    mf = manifest.Manifest().set_dirinfo()
    bytes_written = 0
    vol_num = 0

    # This assertion must be kept until we have solved the problem
    # of concurrency at the backend level. Concurrency 1 is fine
    # because the actual I/O concurrency on backends is limited to
    # 1 as usual, but we are allowed to perform local CPU
    # intensive tasks while that single upload is happening. This
    # is an assert put in place to avoid someone accidentally
    # enabling concurrency above 1, before adequate work has been
    # done on the backends to make them support concurrency.
    assert globals.async_concurrency <= 1

    io_scheduler = asyncscheduler.AsyncScheduler(globals.async_concurrency)
    async_waiters = []

    while not at_end:
        # Create volume
        tarblock_iter.remember_next_index() # keep track of start index
        vol_num += 1
        dest_filename = file_naming.get(backup_type, vol_num,
                                        encrypted = globals.encryption,
                                        gzipped = not globals.encryption)
        tdp = dup_temp.new_tempduppath(file_naming.parse(dest_filename))
        if globals.encryption:
            at_end = gpg.GPGWriteFile(tarblock_iter, tdp.name,
                                      globals.gpg_profile, globals.volsize)
        else:
            at_end = gpg.GzipWriteFile(tarblock_iter, tdp.name, globals.volsize)
        tdp.setdata()

        # Add volume information to manifest
        vi = manifest.VolumeInfo()
        start_index, end_index = get_indicies(tarblock_iter)
        vi.set_info(vol_num, start_index, end_index)
        vi.set_hash("SHA1", gpg.get_hash("SHA1", tdp))
        mf.add_volume_info(vi)

        async_waiters.append(io_scheduler.schedule_task(lambda tdp, dest_filename: put(tdp, dest_filename),
                                (tdp, dest_filename)))

        # Log human-readable version as well as raw numbers for machine consumers
        log.Progress('Processed volume %d' % vol_num, diffdir.stats.SourceFileSize)

    # Collect byte count from all asynchronous jobs; also implicitly waits
    # for them all to complete.
    for waiter in async_waiters:
        bytes_written += waiter()

    # Upload the collection summary.
    bytes_written += write_manifest(mf, backup_type, backend)

    return bytes_written


def write_manifest(mf, backup_type, backend):
    """
    Write manifest to file in archive_dir and encrypted to backend

    @type mf: Manifest object
    @param mf: manifest to write
    @type backup_type: string
    @param backup_type: type of backup to perform, either 'inc' or 'full'
    @type backend: callable backend object
    @param backend: I/O backend for selected protocol

    @rtype: int
    @return: bytes written
    """
    mf_string = mf.to_string()
    if globals.archive_dir:
        local_mf_name = file_naming.get(backup_type, manifest = 1)
        fin = dup_temp.get_fileobj_duppath(globals.archive_dir, local_mf_name)
        fin.write(mf_string)
        fin.close()

    sizelist = [] # will hold length of file in bytes
    remote_mf_name = file_naming.get(backup_type, manifest = 1,
                                     encrypted = globals.encryption)
    remote_fin = backend.get_fileobj_write(remote_mf_name, sizelist = sizelist)
    remote_fin.write(mf_string)
    remote_fin.close()
    return sizelist[0]


def get_sig_fileobj(sig_type):
    """
    Return a fileobj opened for writing, save results as signature

    If globals.archive_dir is available, save signatures there
    gzipped.  Save them on the backend encrypted as needed.

    @type sig_type: string
    @param sig_type: either "full-sig" or "new-sig"

    @rtype: fileobj
    @return: fileobj opened for writing
    """
    assert sig_type == "full-sig" or sig_type == "new-sig"

    sig_filename = file_naming.get(sig_type, encrypted = globals.encryption,
                                   gzipped = not globals.encryption)
    fh = globals.backend.get_fileobj_write(sig_filename)

    # by MDR.  This was changed to use addfilehandle so we get both
    # remote and local sig files
    if globals.archive_dir:
        local_sig_filename = file_naming.get(sig_type, gzipped = 1)
        fh.addfilehandle(dup_temp.get_fileobj_duppath(globals.archive_dir,
                                                      local_sig_filename))
    return fh


def full_backup(col_stats):
    """
    Do full backup of directory to backend, using archive_dir

    @type col_stats: CollectionStatus object
    @param col_stats: collection status

    @rtype: void
    @return: void
    """
    if globals.dry_run:
        tarblock_iter = diffdir.DirFull(globals.select)
        bytes_written = dummy_backup(tarblock_iter)
        col_stats.set_values(sig_chain_warning = None)
    else:
        sig_outfp = get_sig_fileobj("full-sig")
        tarblock_iter = diffdir.DirFull_WriteSig(globals.select, sig_outfp)
        bytes_written = write_multivol("full", tarblock_iter, globals.backend)
        sig_outfp.close()
        col_stats.set_values(sig_chain_warning = None).cleanup_signatures()
    print_statistics(diffdir.stats, bytes_written)


def check_sig_chain(col_stats):
    """
    Get last signature chain for inc backup, or None if none available

    @type col_stats: CollectionStatus object
    @param col_stats: collection status
    """
    if not col_stats.matched_chain_pair:
        if globals.incremental:
            log.FatalError(_("Fatal Error: Unable to start incremental backup.  "
                             "Old signatures not found and incremental specified"),
                           log.ErrorCode.inc_without_sigs)
        else:
            log.Warn(_("No signatures found, switching to full backup."))
        return None
    return col_stats.matched_chain_pair[0]


def print_statistics(stats, bytes_written):
    """
    If globals.print_statistics, print stats after adding bytes_written

    @rtype: void
    @return: void
    """
    if globals.print_statistics:
        diffdir.stats.TotalDestinationSizeChange = bytes_written
        print diffdir.stats.get_stats_logstring(_("Backup Statistics"))


def incremental_backup(sig_chain):
    """
    Do incremental backup of directory to backend, using archive_dir

    @rtype: void
    @return: void
    """
    dup_time.setprevtime(sig_chain.end_time)
    if dup_time.curtime == dup_time.prevtime:
        time.sleep(1)
        dup_time.setcurtime()
    if globals.dry_run:
        tarblock_iter = diffdir.DirDelta(globals.select,
                                         sig_chain.get_fileobjs())
        bytes_written = dummy_backup(tarblock_iter)
    else:
        new_sig_outfp = get_sig_fileobj("new-sig")
        tarblock_iter = diffdir.DirDelta_WriteSig(globals.select,
                                                  sig_chain.get_fileobjs(),
                                                  new_sig_outfp)
        bytes_written = write_multivol("inc", tarblock_iter, globals.backend)
        new_sig_outfp.close()
    print_statistics(diffdir.stats, bytes_written)


def list_current(col_stats):
    """
    List the files current in the archive (examining signature only)

    @type col_stats: CollectionStatus object
    @param col_stats: collection status

    @rtype: void
    @return: void
    """
    sig_chain = check_sig_chain(col_stats)
    if not sig_chain:
        log.FatalError(_("No signature data found, unable to list files."),
                       log.ErrorCode.no_sigs)
    time = globals.restore_time # if None, will use latest
    path_iter = diffdir.get_combined_path_iter(sig_chain.get_fileobjs(time))
    for path in path_iter:
        if path.difftype != "deleted":
            user_info = "%s %s" % (dup_time.timetopretty(path.getmtime()),
                                   path.get_relative_path())
            log_info = "%s %s" % (dup_time.timetostring(path.getmtime()),
                                  util.escape(path.get_relative_path()))
            log.Log(user_info, log.INFO, log.InfoCode.file_list,
                    log_info, True)


def restore(col_stats):
    """
    Restore archive in globals.backend to globals.local_path

    @type col_stats: CollectionStatus object
    @param col_stats: collection status

    @rtype: void
    @return: void
    """
    if globals.dry_run:
      return
    if not patchdir.Write_ROPaths(globals.local_path,
                                  restore_get_patched_rop_iter(col_stats)):
        if globals.restore_dir:
            log.FatalError(_("%s not found in archive, no files restored.")
                           % (globals.restore_dir,),
                           log.ErrorCode.restore_dir_not_found)
        else:
            log.FatalError(_("No files found in archive - nothing restored."),
                           log.ErrorCode.no_restore_files)


def restore_get_patched_rop_iter(col_stats):
    """
    Return iterator of patched ROPaths of desired restore data

    @type col_stats: CollectionStatus object
    @param col_stats: collection status
    """
    if globals.restore_dir:
        index = tuple(globals.restore_dir.split("/"))
    else:
        index = ()
    time = globals.restore_time or dup_time.curtime
    backup_chain = col_stats.get_backup_chain_at_time(time)
    assert backup_chain, col_stats.all_backup_chains
    backup_setlist = backup_chain.get_sets_at_time(time)
    num_vols = 0
    for s in backup_setlist:
        num_vols += len(s)
    cur_vol = [0]

    def get_fileobj_iter(backup_set):
        """Get file object iterator from backup_set contain given index"""
        manifest = backup_set.get_manifest()
        volumes = manifest.get_containing_volumes(index)
        for vol_num in volumes:
            yield restore_get_enc_fileobj(backup_set.backend,
                                          backup_set.volume_name_dict[vol_num],
                                          manifest.volume_info_dict[vol_num])
            cur_vol[0] += 1
            log.Progress(_('Processed volume %d of %d') % (cur_vol[0], num_vols),
                         cur_vol[0], num_vols)

    fileobj_iters = map(get_fileobj_iter, backup_setlist)
    tarfiles = map(patchdir.TarFile_FromFileobjs, fileobj_iters)
    return patchdir.tarfiles2rop_iter(tarfiles, index)


def restore_get_enc_fileobj(backend, filename, volume_info):
    """
    Return plaintext fileobj from encrypted filename on backend

    If volume_info is set, the hash of the file will be checked,
    assuming some hash is available.  Also, if globals.sign_key is
    set, a fatal error will be raised if file not signed by sign_key.

    """
    parseresults = file_naming.parse(filename)
    tdp = dup_temp.new_tempduppath(parseresults)
    backend.get(filename, tdp)
    restore_check_hash(volume_info, tdp)

    fileobj = tdp.filtered_open_with_delete("rb")
    if parseresults.encrypted and globals.gpg_profile.sign_key:
        restore_add_sig_check(fileobj)
    return fileobj


def restore_check_hash(volume_info, vol_path):
    """
    Check the hash of vol_path path against data in volume_info

    @rtype: void
    @return: void
    """
    hash_pair = volume_info.get_best_hash()
    if hash_pair:
        calculated_hash = gpg.get_hash(hash_pair[0], vol_path)
        if calculated_hash != hash_pair[1]:
            log.FatalError("%s\n%s\n%s\n" %
                           (_("Invalid data - %s hash mismatch:") % hash_pair[0],
                            _("Calculated hash: %s") % calculated_hash,
                            _("Manifest hash: %s") % hash_pair[1]),
                           log.ErrorCode.mismatched_hash)


def restore_add_sig_check(fileobj):
    """
    Require signature when closing fileobj matches sig in gpg_profile

    @rtype: void
    @return: void
    """
    assert (isinstance(fileobj, dup_temp.FileobjHooked) and
            isinstance(fileobj.fileobj, gpg.GPGFile)), fileobj
    def check_signature():
        """Thunk run when closing volume file"""
        actual_sig = fileobj.fileobj.get_signature()
        if actual_sig != globals.gpg_profile.sign_key:
            log.FatalError(_("Volume was signed by key %s, not %s") %
                           (actual_sig, globals.gpg_profile.sign_key),
                           log.ErrorCode.unsigned_volume)
    fileobj.addhook(check_signature)


def verify(col_stats):
    """
    Verify files, logging differences

    @type col_stats: CollectionStatus object
    @param col_stats: collection status

    @rtype: void
    @return: void
    """
    global exit_val
    collated = diffdir.collate2iters(restore_get_patched_rop_iter(col_stats),
                                     globals.select)
    diff_count = 0; total_count = 0
    for backup_ropath, current_path in collated:
        if not backup_ropath:
            backup_ropath = path.ROPath(current_path.index)
        if not current_path:
            current_path = path.ROPath(backup_ropath.index)
        if not backup_ropath.compare_verbose(current_path):
            diff_count += 1
        total_count += 1
    # Unfortunately, ngettext doesn't handle multiple number variables, so we
    # split up the string.
    log.Notice(_("Verify complete: %s, %s.") %
               (gettext.ngettext("%d file compared",
                                 "%d files compared", total_count) % total_count,
                gettext.ngettext("%d difference found",
                                 "%d differences found", diff_count) % diff_count))
    if diff_count >= 1:
        exit_val = 1


def cleanup(col_stats):
    """
    Delete the extraneous files in the current backend

    @type col_stats: CollectionStatus object
    @param col_stats: collection status

    @rtype: void
    @return: void
    """
    extraneous = col_stats.get_extraneous()
    if not extraneous:
        log.Warn(_("No extraneous files found, nothing deleted in cleanup."))
        return

    filestr = "\n".join(extraneous)
    if globals.force:
        log.Notice(gettext.ngettext("Deleting this file from backend:",
                                    "Deleting these files from backend:",
                                    len(extraneous))+"\n"+filestr)
        if not globals.dry_run:
            col_stats.backend.delete(extraneous)
    else:
        log.Notice("%s\n%s\n%s" %
                   (gettext.ngettext("Found the following file to delete:",
                                     "Found the following files to delete:",
                                     len(extraneous)),
                    filestr,
                    _("Run duplicity again with the --force option to actually delete.")))


def remove_all_but_n_full(col_stats):
    """
    Remove backup files older than the last n full backups.

    @type col_stats: CollectionStatus object
    @param col_stats: collection status

    @rtype: void
    @return: void
    """
    assert globals.keep_chains is not None

    globals.remove_time = col_stats.get_nth_last_full_backup_time(globals.keep_chains)

    remove_old(col_stats)


def remove_old(col_stats):
    """
    Remove backup files older than globals.remove_time from backend

    @type col_stats: CollectionStatus object
    @param col_stats: collection status

    @rtype: void
    @return: void
    """
    assert globals.remove_time is not None
    def set_times_str(setlist):
        """Return string listing times of sets in setlist"""
        return "\n".join(map(lambda s: dup_time.timetopretty(s.get_time()),
                             setlist))

    req_list = col_stats.get_older_than_required(globals.remove_time)
    if req_list:
        log.Warn("%s\n%s\n%s" %
                 (_("There are backup set(s) at time(s):"),
                  set_times_str(req_list),
                  _("Which can't be deleted because newer sets depend on them.")))

    if (col_stats.matched_chain_pair and
        col_stats.matched_chain_pair[1].end_time < globals.remove_time):
        log.Warn(_("Current active backup chain is older than specified time.  "
                   "However, it will not be deleted.  To remove all your backups, "
                   "manually purge the repository."))

    setlist = col_stats.get_older_than(globals.remove_time)
    if not setlist:
        log.Warn(_("No old backup sets found, nothing deleted."))
        return
    if globals.force:
        log.Notice(gettext.ngettext("Deleting backup set at time:",
                                    "Deleting backup sets at times:",
                                    len(setlist)) +
                   "\n" + set_times_str(setlist))
        if globals.dry_run:
            col_stats.set_values(sig_chain_warning = None)
        else:
            setlist.reverse() # save oldest for last
            for set in setlist:
                set.delete()
            col_stats.set_values(sig_chain_warning = None).cleanup_signatures()
    else:
        log.Notice(gettext.ngettext("Found old backup set at the following time:",
                                    "Found old backup sets at the following times:",
                                    len(setlist)) +
                   "\n" + set_times_str(setlist) + "\n" +
                   _("Rerun command with --force option to actually delete."))


def check_last_manifest(col_stats):
    """
    Check consistency and hostname/directory of last manifest

    @type col_stats: CollectionStatus object
    @param col_stats: collection status

    @rtype: void
    @return: void
    """
    if not col_stats.all_backup_chains:
        return
    last_backup_set = col_stats.all_backup_chains[-1].get_last()
    last_backup_set.check_manifests()


def check_resources(action):
    """
    Check for sufficient resources:
      - temp space for volume build
      - enough max open files
    Put out fatal error if not sufficient to run

    @type action: string
    @param action: action in progress

    @rtype: void
    @return: void
    """
    if action in ["full", "inc", "restore"]:
        # Make sure we have enough resouces to run
        # First check disk space in temp area.
        tempfile, tempname = tempdir.default().mkstemp()
        os.close(tempfile)
        # strip off the temp dir and file
        tempfs = os.path.sep.join(tempname.split(os.path.sep)[:-2])
        try:
            stats = os.statvfs(tempfs)
        except:
            log.FatalError(_("Unable to get free space on temp."),
                           log.ErrorCode.get_freespace_failed)
        # Calculate space we need for at least 2 volumes of full or inc
        # plus about 30% of one volume for the signature files.
        freespace = stats[statvfs.F_FRSIZE] * stats[statvfs.F_BAVAIL]
        needspace = (((globals.async_concurrency + 1) * globals.volsize)
                     + int(0.30 * globals.volsize))
        if freespace < needspace:
            log.FatalError(_("Temp space has %d available, backup needs approx %d.") %
                           (freespace, needspace), log.ErrorCode.not_enough_freespace)
        else:
            log.Info(_("Temp has %d available, backup will use approx %d.") %
                     (freespace, needspace))

        # Some environments like Cygwin run with an artificially
        # low value for max open files.  Check for safe number.
        try:
            soft, hard = resource.getrlimit(resource.RLIMIT_NOFILE)
        except resource.error:
            log.FatalError(_("Unable to get max open files."),
                           log.ErrorCode.get_ulimit_failed)
        maxopen = min([l for l in (soft, hard) if l > -1])
        if maxopen < 1024:
            log.FatalError(_("Max open files of %s is too low, should be >= 1024.\n"
                             "Use 'ulimit -n 1024' or higher to correct.\n") % (maxopen,),
                             log.ErrorCode.maxopen_too_low)


def main():
    """
    Start/end here
    """
    dup_time.setcurtime()
    log.setup()
    action = commandline.ProcessCommandLine(sys.argv[1:])

    # log Python, duplicity, and system versions
    log.Info("Args: %s" % (' '.join(sys.argv),))
    log.Info("%s %s" % (sys.executable or sys.platform, sys.version))
    log.Info("duplicity $version ($reldate)")
    log.Info(' '.join(platform.uname()))

    check_resources(action)

    col_stats = collections.CollectionsStatus(globals.backend,
                                              globals.archive_dir).set_values()
    log.PrintCollectionStatus(col_stats)

    last_full_time = col_stats.get_last_full_backup_time()
    if last_full_time > 0:
        log.Notice(_("Last full backup date:") + " " + dup_time.timetopretty(last_full_time))
    else:
        log.Notice(_("Last full backup date: none"))
    if action == "inc" and last_full_time < globals.full_force_time:
        log.Notice(_("Last full backup is too old, forcing full backup"))
        action = "full"

    os.umask(077)

    globals.gpg_profile.passphrase = get_passphrase(1, action)

    if action == "restore":
        restore(col_stats)
    elif action == "verify":
        verify(col_stats)
    elif action == "list-current":
        list_current(col_stats)
    elif action == "collection-status":
        log.PrintCollectionStatus(col_stats, True)
    elif action == "cleanup":
        cleanup(col_stats)
    elif action == "remove-old":
        remove_old(col_stats)
    elif action == "remove-all-but-n-full":
        remove_all_but_n_full(col_stats)
    else:
        assert action == "inc" or action == "full", action
        if action == "full":
            globals.gpg_profile.passphrase = get_passphrase(2, action)
            full_backup(col_stats)
        else:  # attempt incremental
            sig_chain = check_sig_chain(col_stats)
            if not sig_chain:
                globals.gpg_profile.passphrase = get_passphrase(2, action)
                full_backup(col_stats)
            else:
                check_last_manifest(col_stats) # not needed for full backup
                incremental_backup(sig_chain)
    globals.backend.close()
    log.shutdown()
    if exit_val is not None:
        sys.exit(exit_val)


def with_tempdir(fn):
    """
    Execute function and guarantee cleanup of tempdir is called

    @type fn: callable function
    @param fn: function to execute

    @return: void
    @rtype: void
    """
    try:
        fn()
    finally:
        tempdir.default().cleanup()


if __name__ == "__main__":
    try:
        with_tempdir(main)

    # Don't move this lower.  In order to get an exit
    # status out of the system, you have to call the
    # sys.exit() function.  Python handles this by
    # raising the SystemExit exception.  Cleanup code
    # goes here, if needed.
    except SystemExit, e:
        # No traceback, just get out
        sys.exit(e)

    except gpg.GPGError, e:
        # For user errors, don't show an ugly stack trace by
        # default. But do with sufficient verbosity.
        log.Info(_("GPG error detail: %s")
                 % (''.join(traceback.format_exception(*sys.exc_info()))))
        log.FatalError("%s: %s" % (e.__class__.__name__, e.args[0]),
                       log.ErrorCode.gpg_failed,
                       e.__class__.__name__)

    except duplicity.errors.UserError, e:
        # For user errors, don't show an ugly stack trace by
        # default. But do with sufficient verbosity.
        log.Info(_("User error detail: %s")
                 % (''.join(traceback.format_exception(*sys.exc_info()))))
        log.FatalError("%s: %s" % (e.__class__.__name__, str(e)),
                       log.ErrorCode.user_error,
                       e.__class__.__name__)

    except duplicity.errors.BackendException, e:
        # For backend errors, don't show an ugly stack trace by
        # default. But do with sufficient verbosity.
        log.Info(_("Backend error detail: %s")
                 % (''.join(traceback.format_exception(*sys.exc_info()))))
        log.FatalError("%s: %s" % (e.__class__.__name__, str(e)),
                       log.ErrorCode.user_error,
                       e.__class__.__name__)

    except Exception, e:
        # Traceback and that mess
        log.FatalError("%s" % (''.join(traceback.format_exception(*sys.exc_info()))),
                       log.ErrorCode.exception,
                       e.__class__.__name__)
